#!/usr/bin/env node
const path = require('path');
const { queue } = require('async');
const s3Helper = require('./s3-helper');
const { ensureEnv } = require('./env-helper');

const OBJECT_COPY_CONCURRENCY = 10;

const ensureConfigForEnv = env => {
  const sanitizedEnv = (env || '').trim().toUpperCase();

  return {
    s3Endpoint: ensureEnv(`S3_ENDPOINT_${sanitizedEnv}`),
    s3Region: ensureEnv(`S3_REGION_${sanitizedEnv}`),
    s3AccessKey: ensureEnv(`S3_ACCESS_KEY_${sanitizedEnv}`),
    s3SecretKey: ensureEnv(`S3_SECRET_KEY_${sanitizedEnv}`),
    s3BucketName: ensureEnv(`S3_BUCKET_NAME_${sanitizedEnv}`),
    s3ObjectsPrefix: ensureEnv(`S3_OBJECTS_PREFIX_${sanitizedEnv}`)
  };
};

const getConfigFromParsingArguments = () => {
  const args = process.argv;
  const from = args.indexOf('-from');
  const fromEnv = args[from + 1];

  if (from === -1 || !fromEnv) {
    throw new Error('Expected arguments: -from \'fromEnvironment\'');
  }

  const fromConfig = ensureConfigForEnv(fromEnv);

  return {
    sourceEnv: fromConfig
  };
};

(async () => {
  const { sourceEnv } = getConfigFromParsingArguments();

  const sourceS3 = s3Helper.createS3(sourceEnv);
  const sourceObjects = await s3Helper.listAllObjects({ s3: sourceS3, bucketName: sourceEnv.s3BucketName, prefix: sourceEnv.s3ObjectsPrefix });

  console.log(`Downloading ${sourceObjects.length} objects from ${sourceEnv.s3BucketName}/${sourceEnv.s3ObjectsPrefix}`);

  let errorOccurred = false;
  const downloadDir = path.resolve(`./download_${sourceEnv.s3BucketName}_${sourceEnv.s3ObjectsPrefix}`);

  const q = queue(({ obj }, callback) => {
    s3Helper.downloadObject({
      sourceS3,
      sourceBucketName: sourceEnv.s3BucketName,
      objectKey: obj.Key
    }, downloadDir).then(() => callback?.(), err => callback?.(err));
  }, OBJECT_COPY_CONCURRENCY);

  q.error((err, { obj }) => {
    console.error(`Error while downloading ${obj.Key}`, err);
    errorOccurred = true;
    q.remove(() => true);
  });

  q.push(sourceObjects.map((obj, index) => ({ obj, index })));

  await q.drain();

  if (errorOccurred) {
    console.error('CANCELLED BECAUSE OF ERRORS!');
  } else {
    console.log('SUCESSFULLY FINISHED!');
  }

})();
